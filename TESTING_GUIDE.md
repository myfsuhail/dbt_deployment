# dbt Testing Guide: Comprehensive Testing Strategies

This guide provides an in-depth look at the testing strategies implemented in this dbt e-commerce analytics project, showcasing best practices for ensuring data quality and reliability.

## Table of Contents
1. [Why Test in dbt?](#why-test-in-dbt)
2. [Testing Philosophy](#testing-philosophy)
3. [Schema Tests (Generic Tests)](#schema-tests-generic-tests)
4. [Singular Tests (Custom SQL Tests)](#singular-tests-custom-sql-tests)
5. [Testing by Layer](#testing-by-layer)
6. [Advanced Testing Patterns](#advanced-testing-patterns)
7. [Test Execution & Debugging](#test-execution--debugging)
8. [Best Practices](#best-practices)

---

## Why Test in dbt?

### The Business Case
- **Prevent Data Quality Issues** - Catch errors before they reach dashboards and reports
- **Build Stakeholder Trust** - Demonstrate reliability through automated quality checks
- **Reduce Manual QA** - Automated tests run consistently on every build
- **Enable Confident Changes** - Refactor with assurance that logic remains correct
- **Document Assumptions** - Tests serve as living documentation of business rules

### The Cost of Bad Data
```
Bad Data → Wrong Metrics → Poor Decisions → Lost Revenue
```

A single incorrect metric can lead to:
- Misallocated marketing budgets
- Incorrect inventory planning
- Failed A/B test interpretations
- Lost executive confidence

**Testing is insurance against these failures.**

---

## Testing Philosophy

This project follows a **layered testing approach**:

```
┌─────────────────────────────────────────────────────┐
│                   MARTS LAYER                       │
│  Tests: Business KPIs, Customer Segments, Revenue   │
├─────────────────────────────────────────────────────┤
│               INTERMEDIATE LAYER                    │
│  Tests: Calculations, Joins, Foreign Keys          │
├─────────────────────────────────────────────────────┤
│                 STAGING LAYER                       │
│  Tests: Data Types, Nulls, Primary Keys            │
├─────────────────────────────────────────────────────┤
│                  SEED LAYER                         │
│  Tests: Source Data Integrity                      │
└─────────────────────────────────────────────────────┘
```

### Key Principles
1. **Test Early** - Validate at the staging layer before issues cascade
2. **Test Often** - Every model should have at least one test
3. **Test Appropriately** - Use the right test type for each scenario
4. **Test Meaningfully** - Focus on business-critical validations

---

## Schema Tests (Generic Tests)

Schema tests are **reusable, parameterized tests** defined in YAML files alongside your model definitions.

### Built-in Schema Tests

#### 1. `unique`
**Purpose:** Ensures a column has no duplicate values

**Use Cases:**
- Primary keys (customer_id, order_id, product_id)
- Natural keys (email, SKU)
- Surrogate keys generated by dbt

**Example:**
```yaml
# models/staging/_staging__models.yml
models:
  - name: stg_customers
    columns:
      - name: customer_id
        tests:
          - unique
```

**SQL Behind the Scenes:**
```sql
SELECT customer_id, COUNT(*) as n_records
FROM staging.stg_customers
GROUP BY customer_id
HAVING COUNT(*) > 1
```

#### 2. `not_null`
**Purpose:** Ensures a column has no NULL values

**Use Cases:**
- Primary keys
- Foreign keys (required relationships)
- Business-critical fields (order_date, product_name)

**Example:**
```yaml
models:
  - name: stg_orders
    columns:
      - name: customer_id
        tests:
          - not_null
      - name: order_date
        tests:
          - not_null
```

#### 3. `accepted_values`
**Purpose:** Validates that a column contains only specified values

**Use Cases:**
- Status fields (order_status: pending, completed, cancelled)
- Category fields (product_category: electronics, clothing)
- Boolean flags (is_active: true, false)

**Example:**
```yaml
models:
  - name: stg_orders
    columns:
      - name: status
        tests:
          - accepted_values:
              values: ['completed', 'pending', 'cancelled', 'returned']
```

**SQL Behind the Scenes:**
```sql
SELECT *
FROM staging.stg_orders
WHERE status NOT IN ('completed', 'pending', 'cancelled', 'returned')
```

#### 4. `relationships`
**Purpose:** Validates referential integrity (foreign key constraints)

**Use Cases:**
- Order → Customer relationships
- Order Item → Product relationships
- Fact → Dimension relationships

**Example:**
```yaml
models:
  - name: int_order_items
    columns:
      - name: customer_id
        tests:
          - relationships:
              to: ref('stg_customers')
              field: customer_id
```

**SQL Behind the Scenes:**
```sql
SELECT *
FROM intermediate.int_order_items oi
LEFT JOIN staging.stg_customers c ON oi.customer_id = c.customer_id
WHERE c.customer_id IS NULL
```

### Combining Multiple Tests

You can (and should!) apply multiple tests to important columns:

```yaml
models:
  - name: dim_customers
    columns:
      - name: customer_id
        description: "Primary key for customers"
        tests:
          - unique
          - not_null
```

This is so common that dbt provides a shorthand:

```yaml
columns:
  - name: customer_id
    tests:
      - unique
      - not_null
```

---

## Singular Tests (Custom SQL Tests)

Singular tests are **custom SQL queries** that return failing rows. If the query returns any rows, the test fails.

### Test Structure

Location: `tests/` directory

**Template:**
```sql
-- tests/my_custom_test.sql
-- Description: What this test validates

SELECT *
FROM {{ ref('my_model') }}
WHERE [condition that should NOT be true]
```

**If this query returns rows → Test FAILS**

### Implemented Singular Tests

#### 1. No Negative Quantities
**File:** `tests/no_negative_quantities.sql`

**Purpose:** Ensure order quantities are always positive

```sql
-- Order quantities should always be positive
-- If this test returns rows, we have data quality issues

SELECT 
    order_id,
    product_id,
    quantity
FROM {{ ref('stg_orders') }}
WHERE quantity < 0
```

**Business Rule:** You cannot order negative quantities of a product

**Impact if Violated:** 
- Incorrect inventory calculations
- Wrong revenue reporting
- Negative stock levels

#### 2. No Future Order Dates
**File:** `tests/no_future_order_dates.sql`

**Purpose:** Prevent data entry errors with future dates

```sql
-- Orders should not have dates in the future
-- This catches data entry errors and system clock issues

SELECT 
    order_id,
    customer_id,
    order_date
FROM {{ ref('stg_orders') }}
WHERE order_date > CURRENT_DATE
```

**Business Rule:** Cannot place an order in the future

**Impact if Violated:**
- Skewed time-series analysis
- Incorrect forecasting baselines
- Dashboard anomalies

#### 3. No Negative Margins
**File:** `tests/no_negative_margin.sql`

**Purpose:** Flag items selling at a loss (with tolerance for rounding)

```sql
-- Most items should have positive margin
-- Allow small negative values for rounding errors
-- But large negative margins indicate data issues

SELECT 
    order_id,
    product_id,
    product_name,
    revenue,
    cost,
    margin
FROM {{ ref('int_order_items') }}
WHERE margin < -0.50  -- Tolerance for rounding
```

**Business Rule:** Products should generally be profitable

**Impact if Violated:**
- Incorrect profitability analysis
- Misinformed pricing decisions
- Hidden loss-leaders

**Note:** This uses a tolerance threshold (-0.50) to allow for rounding errors while catching significant issues.

#### 4. Revenue Calculation Accuracy
**File:** `tests/revenue_matches_calculation.sql`

**Purpose:** Validate that derived revenue matches the calculation

```sql
-- Revenue should equal quantity * unit_price
-- This validates our calculation logic

SELECT 
    order_id,
    product_id,
    quantity,
    unit_price,
    revenue,
    (quantity * unit_price) as expected_revenue,
    ABS(revenue - (quantity * unit_price)) as difference
FROM {{ ref('int_order_items') }}
WHERE ABS(revenue - (quantity * unit_price)) > 0.01  -- Allow 1 cent rounding
```

**Business Rule:** Revenue = Quantity × Unit Price

**Impact if Violated:**
- Incorrect revenue reporting
- Mismatch with accounting systems
- Lost trust in analytics

---

## Testing by Layer

### Seed Layer Tests
**Location:** `models/seeds/_seeds__schema.yml`

**Focus:** Source data integrity

```yaml
seeds:
  - name: raw_customers
    description: "Raw customer master data"
    columns:
      - name: customer_id
        tests:
          - unique
          - not_null
          
  - name: raw_orders
    columns:
      - name: order_id
        tests:
          - unique
          - not_null
      - name: status
        tests:
          - accepted_values:
              values: ['completed', 'pending', 'cancelled', 'returned']
```

**Why Test Seeds?**
- Seeds are your "ground truth" data
- Validating seeds early prevents cascading failures
- Ensures data hygiene before transformation

### Staging Layer Tests
**Location:** `models/staging/_staging__models.yml`

**Focus:** Data type validation, primary keys, basic constraints

```yaml
models:
  - name: stg_customers
    description: "Cleaned customer data with standardized formats"
    columns:
      - name: customer_id
        description: "Primary key"
        tests:
          - unique
          - not_null
      - name: email
        description: "Lowercase, trimmed email"
        tests:
          - not_null
          
  - name: stg_orders
    columns:
      - name: order_id
        tests:
          - unique
          - not_null
      - name: customer_id
        description: "Foreign key to customers"
        tests:
          - not_null
      - name: status
        tests:
          - accepted_values:
              values: ['completed', 'pending', 'cancelled', 'returned']
```

**Singular Tests at Staging:**
- `no_negative_quantities.sql` - Applied to stg_orders
- `no_future_order_dates.sql` - Applied to stg_orders

### Intermediate Layer Tests
**Location:** `models/intermediate/_intermediate__models.yml`

**Focus:** Relationships, business logic, calculated fields

```yaml
models:
  - name: int_order_items
    description: "Orders joined with products, with revenue/cost/margin calculated"
    columns:
      - name: customer_id
        description: "Foreign key to customers"
        tests:
          - not_null
          - relationships:
              to: ref('stg_customers')
              field: customer_id
      - name: product_id
        description: "Foreign key to products"
        tests:
          - not_null
          - relationships:
              to: ref('stg_products')
              field: product_id
      - name: revenue
        tests:
          - not_null
      - name: margin
        tests:
          - not_null
```

**Singular Tests at Intermediate:**
- `no_negative_margin.sql` - Validates profit calculations
- `revenue_matches_calculation.sql` - Validates revenue logic

### Marts Layer Tests
**Location:** `models/marts/_marts__models.yml`

**Focus:** Business KPIs, dimensional integrity, aggregation accuracy

```yaml
models:
  - name: dim_customers
    description: "Customer dimension with lifetime value segmentation"
    columns:
      - name: customer_id
        description: "Primary key"
        tests:
          - unique
          - not_null
      - name: segment
        description: "Customer value segment"
        tests:
          - accepted_values:
              values: ['high_value', 'medium_value', 'low_value']
      - name: total_revenue
        tests:
          - not_null
      - name: order_count
        tests:
          - not_null
          
  - name: fct_daily_sales
    description: "Daily sales fact table"
    columns:
      - name: order_date
        tests:
          - not_null
      - name: product_id
        tests:
          - not_null
      - name: revenue
        tests:
          - not_null
```

**Why Test Marts Heavily?**
- Marts are consumed directly by BI tools
- Errors here directly impact business decisions
- Final line of defense against bad data

---

## Advanced Testing Patterns

### 1. Store Failures for Debugging

**Configuration in `dbt_project.yml`:**
```yaml
tests:
  ecommerce_analytics:
    +store_failures: true
```

**What This Does:**
- Failed test results are saved as tables in your database
- Allows you to query and analyze failing rows
- Schema: `<target_schema>_dbt_test__audit`

**Example Usage:**
```sql
-- Query failed test results
SELECT * 
FROM dbt_test__audit.no_negative_quantities
WHERE test_failed_at > CURRENT_DATE - 7
```

### 2. Test Severity Levels

**Warning vs Error:**
```yaml
columns:
  - name: margin
    tests:
      - not_null:
          severity: error  # Build fails
      - dbt_utils.at_least_one:
          severity: warn   # Build continues, logs warning
```

**Use Cases:**
- `error` - Critical data quality issues
- `warn` - Nice-to-have checks, monitoring

### 3. Conditional Tests

Test only in production:
```yaml
tests:
  - unique:
      where: "created_at > CURRENT_DATE - 30"  # Only recent data
```

Test only specific subsets:
```yaml
tests:
  - relationships:
      to: ref('dim_products')
      field: product_id
      where: "status = 'completed'"  # Only completed orders
```

### 4. Package-Based Tests (dbt_utils)

This project includes `dbt_utils` which provides additional test macros:

#### equal_rowcount
Ensures two models have the same number of rows:
```yaml
tests:
  - dbt_utils.equal_rowcount:
      compare_model: ref('stg_orders_backup')
```

#### at_least_one
Ensures a column has at least one non-null value:
```yaml
columns:
  - name: created_at
    tests:
      - dbt_utils.at_least_one
```

#### recency
Ensures data is recent:
```yaml
columns:
  - name: order_date
    tests:
      - dbt_utils.recency:
          datepart: day
          interval: 1
```

#### unique_combination_of_columns
Ensures combinations are unique:
```yaml
tests:
  - dbt_utils.unique_combination_of_columns:
      combination_of_columns:
        - order_date
        - product_id
```

---

## Test Execution & Debugging

### Running Tests

**Run all tests:**
```bash
dbt test --profiles-dir .
```

**Run tests for specific model:**
```bash
dbt test --select stg_customers --profiles-dir .
```

**Run tests for specific tag:**
```bash
dbt test --select tag:daily --profiles-dir .
```

**Run only schema tests:**
```bash
dbt test --select test_type:schema --profiles-dir .
```

**Run only singular tests:**
```bash
dbt test --select test_type:singular --profiles-dir .
```

### Understanding Test Output

**Successful test:**
```
12:34:56  1 of 25 START test unique_stg_customers_customer_id ............... [RUN]
12:34:56  1 of 25 PASS unique_stg_customers_customer_id ..................... [PASS in 0.12s]
```

**Failed test:**
```
12:34:57  2 of 25 START test no_negative_quantities ........................ [RUN]
12:34:57  2 of 25 FAIL 3 no_negative_quantities ............................ [FAIL 3 in 0.15s]
```

**This indicates 3 rows failed the test.**

### Debugging Failed Tests

**Step 1:** Check the stored failures (if enabled):
```sql
SELECT * FROM dbt_test__audit.no_negative_quantities;
```

**Step 2:** Manually run the test SQL:
```bash
dbt show --select tests/no_negative_quantities.sql --profiles-dir .
```

**Step 3:** Investigate the source data:
```sql
SELECT * 
FROM staging.stg_orders 
WHERE order_id IN (SELECT order_id FROM dbt_test__audit.no_negative_quantities);
```

**Step 4:** Fix the source data or adjust the test

### CI/CD Integration

Tests are automatically run in GitHub Actions:

```yaml
# .github/workflows/dbt-deploy.yml
- name: Run dbt tests
  run: dbt test --profiles-dir . --target dev
```

**Workflow:**
1. Developer creates pull request
2. GitHub Actions runs `dbt test`
3. If tests fail → PR blocked
4. If tests pass → PR can be merged

---

## Best Practices

### 1. Test Coverage Guidelines

**Minimum Coverage:**
- Every model should have at least ONE test
- All primary keys: `unique` + `not_null`
- All foreign keys: `not_null` + `relationships`

**Recommended Coverage:**
- Staging: Focus on data types and basic constraints
- Intermediate: Focus on business logic and calculations
- Marts: Focus on KPIs and business rules

### 2. When to Use Schema Tests vs Singular Tests

**Use Schema Tests When:**
- Testing common patterns (uniqueness, nulls)
- Testing multiple models the same way
- Need reusable, parameterized tests

**Use Singular Tests When:**
- Complex business logic validation
- Multi-column conditions
- Model-specific edge cases
- Calculation accuracy checks

### 3. Test Naming Conventions

**Schema tests:** Named automatically by dbt
```
unique_stg_customers_customer_id
not_null_stg_orders_order_date
```

**Singular tests:** Use descriptive, business-focused names
```
no_negative_quantities.sql          ✓ Good
no_future_order_dates.sql           ✓ Good
check_orders.sql                    ✗ Too vague
test_1.sql                          ✗ Meaningless
```

### 4. Performance Considerations

**For Large Tables:**
- Use `where` clauses to limit test scope
- Consider sampling for non-critical tests
- Run expensive tests less frequently

**Example:**
```yaml
tests:
  - unique:
      where: "created_at > CURRENT_DATE - 30"  # Last 30 days only
```

### 5. Documentation

**Always document your tests:**
```yaml
columns:
  - name: customer_id
    description: "Unique identifier for each customer"
    tests:
      - unique:
          config:
            severity: error
            error_if: ">0"
            warn_if: ">0"
```

**For singular tests, add comments:**
```sql
-- tests/no_negative_margin.sql
-- Purpose: Flag items selling at a loss
-- Business Rule: Products should generally be profitable
-- Tolerance: -0.50 allows for rounding errors
-- Impact: Affects profitability reporting

SELECT ...
```

### 6. Continuous Improvement

**Monitor test results over time:**
- Track which tests fail most often
- Identify data quality trends
- Refine tests based on production issues

**Iterate on test coverage:**
- Add tests when bugs are found
- Remove tests that never fail (too loose)
- Tighten tests that fail too often (too strict)

---

## Summary

This dbt project demonstrates a comprehensive testing strategy:

| Test Type | Count | Purpose |
|-----------|-------|---------|
| Schema Tests | 25+ | Data structure validation |
| Singular Tests | 4 | Business logic validation |
| Layers Tested | 4 | Seeds → Staging → Intermediate → Marts |
| Foreign Keys | 2 | Referential integrity |

**Key Takeaways:**
1. Test at every layer of your data pipeline
2. Use appropriate test types for each scenario
3. Store failures for debugging
4. Integrate tests into CI/CD
5. Document test purposes and business rules

**Testing is not overhead—it's insurance for your data infrastructure.**

---

## Next Steps

- **[Run the tests locally](SETUP.md)** to see them in action
- **[Explore orchestration](DEPLOYMENT_GUIDE.md)** to see how tests integrate with Airflow/Dagster/Prefect
- **[Review the data model](DATA_MODEL.md)** to understand what's being tested
- **Add your own tests** to extend the project

---

**Questions or suggestions?** Open an issue on GitHub or refer to the [dbt testing documentation](https://docs.getdbt.com/docs/building-a-dbt-project/tests).
